Make an object for each atom and create m for movement if needed.

A list of positions? Make position object for list items

A function for each cell type? See if too similar or not

Function for writing to a file


some cells use parts of other unit cells so it would make sense to inherit the
functions that create sed unit cell

in __init__ of subclasses just call sc method inside population method

to loop over lattice points use a list of vectors and use every combination of
them

Current plan is to use a powerset to allow easy adding of all combinations of
basis vectors

Will make each type of crystal a subset of SC

I think aliasing does not occur because of scope?





Got to replan as it got too crazy...

At the most basic level I have to be able to create new lattice points by
addition of vectors

just use numpy.....XD



If I can hardcode a general vector to move to another identical point in an
adjacent unit cell then I just have to append the result to the original array

So current plan is to store atoms location in an np array and generate new unit
cells by casting some vector to a given region of the matrix (one unit cell's
worth). If the situation arises that I need to be able to display more than one
element I will just have an array for each element

In each subclass I just need to append the new lattice points to the column


So the periodicity will be controlled by a tuple which contains dimensions of
the crystal. I only have to extend the crystal once so I can assume a certain
ordering of unit cells. First extend fully in the x direction, then extend that
line in the y, then extend the area into the z for full crystal.

Make a method to append all unit cells occurring in some direction for some
number of times. I can determine the number of atoms to repeat by taking the
initial size of the matrix and dividing by 3. So in the code just take the size
and offset the generator by that amount each time.


Need to change how I'm doing __init__ as I'm currently overriding the base
class's method


current problem is generators are not giving out more than one atom due to reshaping related issues



At the most basic level I am trying to take stock of all
unit cells currently in the crystal and then extend that
block perpendicularly. Just need number of unit cells
currently in crystal



so once I reshape the array to give one atom per column I
just need to add the vector to (unitCellCount*atomCount)
many atoms


Reshape is cutting along a row first so have to change how data is inputted into arrays



arrays are simply going to store atoms in rows while columns contain x,y,z coordinates


Need to code more intelligently as multiple copies of the same atoms are being
made - these copies will propagate through y and z expansion from x giving a
large number of unnecessary atoms



Now I am going to make several different np arrays grouping atoms that will not
contribute to repeats when expanded in certain directions



I was being a dumb dumb... I simply have to start with only the 0,0,0 point and
project it along a line for each direction. This does however mean that I need to project any non boundary lattice point (n-1) times where n is the number of projections in some direction of the (0,0,0) point


POssible ways to optimise include making from lists rather than np.arrays



I think the easiest way to program this and still have a chance to take
advantage of parallelisation is to just add the extreme lattice points after
the fact


Is it possible to store a three dimensional array where there are three matrices which contain each one of the x,y or z coordinates of each atom

As it is unlikely that creating the crystals is going to be the expensive part of this program I will just do it through python for loops



make vectors using arange, concatenate zeros accordingly, let numpy
broadcasting speed it up a wee bit


now the plan icreat x by arange  for loop over the y parts and then use the np.newaxis trick when it comes to the z's



Just doing for loops for all but the first one
